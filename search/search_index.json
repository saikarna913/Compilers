{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Compilers - CS327","text":""},{"location":"#fluxscriptfs","title":"FluxScript(.fs)","text":""},{"location":"#overview","title":"Overview","text":"<p>This language is designed to be high-level (Python-like), dynamically typed, and functional, suitable for solving competitive programming problems and writing ai scripts. It emphasizes usability, expressive power, and functional programming principles like immutability where practical, while supporting a REPL for interactive development.</p>"},{"location":"#data-types","title":"Data Types","text":"<p>The language supports a minimal yet expressive set of built-in data types.</p>"},{"location":"#primitive-data-types","title":"Primitive Data Types","text":"<ul> <li>Numbers: Integers or floating-point values in decimal notation.</li> <li>Examples: <code>10</code>, <code>3.14</code>, <code>-42.5</code></li> <li>Booleans: Logical values.</li> <li>Examples: <code>True</code>, <code>False</code></li> <li>Strings: Sequences of characters enclosed in double quotes.</li> <li>Examples: <code>\"Hello, world!\"</code>, <code>\"\"</code></li> <li>Arrays: Ordered, mutable collections enclosed in square brackets.</li> <li>Examples: <code>[1, 2, 3]</code>, <code>[\"a\", 2, True]</code></li> <li>Dictionaries: Key-value mappings enclosed in curly braces.</li> <li>Examples: <code>{ \"key\": 42, \"flag\": True }</code></li> </ul>"},{"location":"#variables","title":"Variables","text":"<p>Variables are dynamically typed and lexically scoped. They are declared with <code>let</code> and can be reassigned with <code>assign</code>.</p> <ul> <li>Declaration: <code>let &lt;name&gt; = &lt;expression&gt;</code></li> <li>Example: <code>let x = 10</code></li> <li>Reassignment: <code>&lt;name&gt; assign &lt;expression&gt;</code></li> <li>Example: <code>x assign 20</code></li> <li>Scope: Variables are lexically scoped within their enclosing block or function.</li> </ul>"},{"location":"#operators","title":"Operators","text":""},{"location":"#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Supported operators follow standard mathematical precedence: - <code>+</code> (addition), <code>-</code> (subtraction), <code>*</code> (multiplication), <code>/</code> (division), <code>**</code> (exponentiation), <code>rem</code> (remainder) - Example: <code>10 + 5 * 2</code> evaluates to <code>20</code> (multiplication precedes addition). - Precedence: <code>()</code> &gt; <code>**</code> (right-associative) &gt; <code>* / rem</code> (left-associative) &gt; <code>+ -</code> (left-associative)</p>"},{"location":"#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></li> <li>Example: <code>10 &lt; 20</code> evaluates to <code>True</code></li> </ul>"},{"location":"#logical-operators","title":"Logical Operators","text":"<ul> <li><code>and</code>, <code>or</code>, <code>not</code></li> <li>Example: <code>True and not False</code> evaluates to <code>True</code></li> </ul>"},{"location":"#assignment-operators","title":"Assignment Operators","text":"<ul> <li><code>let</code> (declaration), <code>assign</code> (reassignment)</li> <li>Example: <code>let x = 10</code> <code>x assign x + 1</code></li> </ul>"},{"location":"#control-flow","title":"Control Flow","text":"<p>Control flow constructs use <code>{}</code> blocks for clarity and consistency.</p>"},{"location":"#if-statements","title":"If Statements","text":"<ul> <li>Syntax: <code>if (&lt;condition&gt;) { &lt;block&gt; } [else { &lt;block&gt; }]</code></li> <li>Example:   <code>if (x &lt; 0) {       print \"Negative\"   } else {       print \"Non-negative\"   }</code></li> </ul>"},{"location":"#while-loops","title":"While Loops","text":"<ul> <li>Syntax: <code>while (&lt;condition&gt;) { &lt;block&gt; }</code></li> <li>Example:   <code>let x = 0   while (x &lt; 5) {       print x       x assign x + 1   }</code></li> </ul>"},{"location":"#for-loops","title":"For Loops","text":"<ul> <li>Syntax: <code>for (let i = start to end [step s]) {     &lt;block&gt;}</code></li> <li>Example:   <code>for (let i = 1 to 5) {       print i   }</code></li> </ul>"},{"location":"#print-statements","title":"Print Statements","text":"<ul> <li>Syntax: <code>print &lt;expression&gt;</code></li> <li>Example: <code>print \"Hello, world!\"</code></li> <li>Outputs to the console; supports all data types.</li> </ul>"},{"location":"#functions","title":"Functions","text":"<p>Support for first-class functions, proper closures, and included tail-call elimination for recursion.</p>"},{"location":"#function-definition","title":"Function Definition","text":"<ul> <li>Syntax: <code>func &lt;name&gt;(&lt;param1&gt;, &lt;param2&gt;, ...) { &lt;block&gt; }</code></li> <li>Example:   <code>func add(a, b) {       return a + b   }</code></li> </ul>"},{"location":"#return-statement","title":"Return Statement","text":"<ul> <li>Syntax: <code>return &lt;expression&gt;</code></li> <li>Example:   <code>func square(x) {       return x * x   }</code></li> </ul>"},{"location":"#first-class-functions","title":"First-Class Functions","text":"<p>Functions can be assigned to variables or passed as arguments. - Example:   <code>let double = func(x) { return x * 2 }   print double(5)  // Outputs: 10</code></p>"},{"location":"#closures","title":"Closures","text":"<p>Functions capture their lexical environment. - Example:   <code>func counter() {       let count = 0       return func() {           count assign count + 1           return count       }   }   let c = counter()   print c()  // Outputs: 1   print c()  // Outputs: 2</code></p>"},{"location":"#error-handling","title":"Error Handling","text":"<p>The language provides error messages with line location and a REPL that doesn\u2019t crash on errors. - Division by zero: Raises <code>ZeroDivisionError</code> with line number and suggestion (e.g., \"Check divisor\"). - Syntax errors: Flags malformed expressions with location (e.g., <code>5 +</code> \u2192 \"SyntaxError at line 1: incomplete expression\"). - Example REPL session:   ```</p> <p>let x = 10 / 0   [line 1] Error at '/': Division by zero print x   [line 1] Error at 'x': Undefined variable 'x'   ```</p>"},{"location":"#example-program","title":"Example Program","text":"<pre><code>func fib(n) {\n    if (n &lt;= 1) {\n        return n\n    }\n    return fib(n - 1) + fib(n - 2)\n}\n\nlet x = 10\nprint \"Fibonacci of \" + x + \" is \" + fib(x)\n</code></pre>"},{"location":"bytecode/","title":"FluxScript Bytecode Documentation","text":"<p>This document describes the bytecode operations and structure used by the FluxScript Virtual Machine (VM). The bytecode is generated by the <code>BytecodeCompiler</code> and executed by the <code>BytecodeVM</code>. Each operation is represented by an opcode and optional arguments, which the VM interprets to perform computations, manage data structures, and control program flow.</p>"},{"location":"bytecode/#overview","title":"Overview","text":"<p>The FluxScript VM is a stack-based virtual machine designed to execute bytecode instructions generated from a source program. The VM maintains:</p> <ul> <li>Stack: For operands and intermediate results.</li> <li>Constants Table: Stores literals (integers, floats, strings, function data, etc.).</li> <li>Frames: Manage function calls and local variables, supporting closures.</li> <li>Instruction Set: A sequence of opcodes with arguments that dictate VM behavior.</li> </ul> <p>The <code>BytecodeCompiler</code> transforms an Abstract Syntax Tree (AST) into a sequence of instructions and a constants table. The <code>BytecodeVM</code> executes these instructions, handling operations like arithmetic, control flow, function calls, and data structure manipulation.</p>"},{"location":"bytecode/#bytecode-structure","title":"Bytecode Structure","text":"<p>Each instruction is a tuple of the form <code>(opcode, *args)</code>, where: - <code>opcode</code> is an integer identifying the operation. - <code>*args</code> are zero or more arguments specific to the opcode (e.g., constant indices, variable names, or jump targets).</p> <p>The constants table is a list of values (literals, function data, etc.) referenced by instructions via indices.</p>"},{"location":"bytecode/#opcodes","title":"Opcodes","text":"<p>Below is a comprehensive list of opcodes, grouped by category, along with their descriptions, stack effects, and arguments.</p>"},{"location":"bytecode/#constants-and-literals","title":"Constants and Literals","text":"Opcode Value Description Stack Effect Arguments <code>LOAD_CONST</code> 1 Loads a constant from the constants table onto the stack. Pushes: constant value Index into constants table <code>LOAD_TRUE</code> 2 Loads <code>True</code> onto the stack. Pushes: <code>True</code> None <code>LOAD_FALSE</code> 3 Loads <code>False</code> onto the stack. Pushes: <code>False</code> None"},{"location":"bytecode/#variables","title":"Variables","text":"Opcode Value Description Stack Effect Arguments <code>LOAD_VAR</code> 10 Loads a variable's value onto the stack. Pushes: variable value Variable name (string) <code>STORE_VAR</code> 11 Stores the top stack value into a variable and pushes it back. Pops: value; Pushes: value Variable name (string) <code>REASSIGN_VAR</code> 12 Reassigns a value to an existing variable and pushes it back. Pops: value; Pushes: value Variable name (string)"},{"location":"bytecode/#arithmetic-operations","title":"Arithmetic Operations","text":"Opcode Value Description Stack Effect Arguments <code>ADD</code> 20 Adds the top two stack values. Pops: right, left; Pushes: left + right None <code>SUBTRACT</code> 21 Subtracts the top value from the second-top value. Pops: right, left; Pushes: left - right None <code>MULTIPLY</code> 22 Multiplies the top two stack values. Pops: right, left; Pushes: left * right None <code>DIVIDE</code> 23 Divides the second-top value by the top value. Pops: right, left; Pushes: left / right None <code>EXPONENT</code> 24 Raises the second-top value to the power of the top value. Pops: right, left; Pushes: left ** right None <code>MODULO</code> 25 Computes the remainder of the second-top value divided by the top value. Pops: right, left; Pushes: left % right None <code>NEGATE</code> 26 Negates the top stack value. Pops: value; Pushes: -value None"},{"location":"bytecode/#comparison-operations","title":"Comparison Operations","text":"Opcode Value Description Stack Effect Arguments <code>EQUAL</code> 30 Checks if the top two values are equal. Pops: right, left; Pushes: left == right None <code>NOT_EQUAL</code> 31 Checks if the top two values are not equal. Pops: right, left; Pushes: left != right None <code>LESS_THAN</code> 32 Checks if the second-top value is less than the top value. Pops: right, left; Pushes: left &lt; right None <code>GREATER_THAN</code> 33 Checks if the second-top value is greater than the top value. Pops: right, left; Pushes: left &gt; right None <code>LESS_EQUAL</code> 34 Checks if the second-top value is less than or equal to the top value. Pops: right, left; Pushes: left &lt;= right None <code>GREATER_EQUAL</code> 35 Checks if the second-top value is greater than or equal to the top value. Pops: right, left; Pushes: left &gt;= right None"},{"location":"bytecode/#logical-operations","title":"Logical Operations","text":"Opcode Value Description Stack Effect Arguments <code>AND</code> 40 Performs logical AND on the top two values. Pops: right, left; Pushes: left and right None <code>OR</code> 41 Performs logical OR on the top two values. Pops: right, left; Pushes: left or right None <code>NOT</code> 42 Performs logical NOT on the top value. Pops: value; Pushes: not value None"},{"location":"bytecode/#control-flow","title":"Control Flow","text":"Opcode Value Description Stack Effect Arguments <code>JUMP</code> 50 Jumps unconditionally to the specified instruction. None Instruction index <code>JUMP_IF_FALSE</code> 51 Jumps to the specified instruction if the top value is false. Pops: condition Instruction index <code>JUMP_IF_TRUE</code> 52 Jumps to the specified instruction if the top value is true. Pops: condition Instruction index"},{"location":"bytecode/#functions","title":"Functions","text":"Opcode Value Description Stack Effect Arguments <code>DEFINE_FUNC</code> 60 Defines a function and stores it in the current scope. None Function name (string), constant index (function data) <code>CALL_FUNC</code> 61 Calls a function with the specified number of arguments. Pops: function, args; Pushes: result Number of arguments <code>RETURN</code> 62 Returns from a function with the top stack value. Pops: value; Pushes: value (to parent frame) None <code>LOAD_LAMBDA</code> 63 Loads a lambda function (closure) onto the stack. Pushes: closure Constant index (function data) <code>DICT_FUNC_CALL</code> 64 Calls a function stored in a dictionary. Pops: dict, key, args; Pushes: result Number of arguments"},{"location":"bytecode/#data-structures","title":"Data Structures","text":"Opcode Value Description Stack Effect Arguments <code>BUILD_ARRAY</code> 70 Builds an array from the top N stack elements. Pops: N elements; Pushes: array Number of elements <code>BUILD_DICT</code> 71 Builds a dictionary from N key-value pairs on the stack. Pops: N pairs (key, value); Pushes: dict Number of pairs <code>ARRAY_ACCESS</code> 72 Accesses an element in an array or dictionary. Pops: index, array/dict; Pushes: element None <code>ARRAY_ASSIGN</code> 73 Assigns a value to an array or dictionary element. Pops: value, index, array/dict; Pushes: value None <code>GET_SIZE</code> 74 Gets the size of a string, array, or dictionary. Pops: collection; Pushes: size None <code>MULTI_DIM_ACCESS</code> 75 Accesses a multi-dimensional array element. Pops: N indices, array; Pushes: element Number of indices <code>MULTI_DIM_ASSIGN</code> 76 Assigns a value to a multi-dimensional array element. Pops: value, N indices, array; Pushes: value Number of indices"},{"location":"bytecode/#io-operations","title":"I/O Operations","text":"Opcode Value Description Stack Effect Arguments <code>PRINT</code> 80 Prints the top stack value. Pops: value None"},{"location":"bytecode/#miscellaneous","title":"Miscellaneous","text":"Opcode Value Description Stack Effect Arguments <code>POP</code> 90 Pops and discards the top stack value. Pops: value None <code>DUP</code> 91 Duplicates the top stack value. Pushes: top value None"},{"location":"bytecode/#program-termination","title":"Program Termination","text":"Opcode Value Description Stack Effect Arguments <code>HALT</code> 99 Halts execution. None None"},{"location":"bytecode/#execution-model","title":"Execution Model","text":"<p>The <code>BytecodeVM</code> operates as follows:</p> <ol> <li>Initialization: Creates a global frame and initializes built-in functions (<code>to_string</code>, <code>to_number</code>, <code>split</code>, <code>substring</code>, <code>__append</code>, <code>size</code>, <code>word</code>).</li> <li>Frame Management: Each function call creates a new <code>Frame</code> with its own stack, local variables, and closure environment. Frames are linked to parent frames for variable lookup.</li> <li>Instruction Execution: The VM processes instructions sequentially, updating the instruction pointer (<code>ip</code>), stack, and variables. Jumps modify the <code>ip</code> for control flow.</li> <li>Closures: Functions and lambdas capture their environment, allowing access to variables from outer scopes. The <code>Closure</code> class manages function code, parameters, constants, and environment.</li> <li>Error Handling: The VM raises exceptions for invalid operations, undefined variables, division by zero, etc., stopping execution and reporting errors.</li> </ol>"},{"location":"bytecode/#built-in-functions","title":"Built-in Functions","text":"<p>The VM includes the following built-in functions, accessible in the global scope:</p> <ul> <li><code>to_string(value)</code>: Converts a value to a string.</li> <li><code>to_number(value)</code>: Converts a string to an integer or float.</li> <li><code>split(string, delimiter)</code>: Splits a string by a delimiter into an array.</li> <li><code>substring(string, start, [end])</code>: Extracts a substring from <code>start</code> to <code>end</code> (or end of string).</li> <li><code>__append(array, value)</code>: Appends a value to an array (internal use).</li> <li><code>size(collection)</code>: Returns the length of a string, array, or dictionary.</li> <li><code>word(number)</code>: Converts an integer (1\u20131000) to its English word representation (e.g., 42 \u2192 \"fortytwo\").</li> </ul>"},{"location":"bytecode/#example","title":"Example","text":"<p>Consider the AST for <code>2 + 3</code>:</p> <pre><code>from AST.ast_1 import Integer, BinOp, Token\nast = BinOp(Integer(2), Token('PLUS', '+', 0, 0), Integer(3))\n</code></pre> <p>The <code>BytecodeCompiler</code> generates:</p> <ul> <li>Constants: <code>[2, 3]</code></li> <li>Instructions:   <code>[(LOAD_CONST, 0),  # Load 2    (LOAD_CONST, 1),  # Load 3    (ADD,),           # Add them    (HALT,)]          # Stop</code></li> </ul> <p>The <code>BytecodeVM</code> executes this to produce <code>5</code>.</p>"},{"location":"bytecode/#debugging","title":"Debugging","text":"<p>Set <code>debug=True</code> in the <code>BytecodeVM</code> constructor to print:</p> <ul> <li>Current instruction pointer (<code>ip</code>).</li> <li>Executed opcode name.</li> <li>Stack contents.</li> <li>Local variables and closure environment (if applicable).</li> </ul> <p>This aids in tracing execution and diagnosing issues.</p>"},{"location":"bytecode/#notes","title":"Notes","text":"<ul> <li>Variable Scope: Variables are looked up in the current frame's locals, then the closure environment, and finally parent frames.</li> <li>Closures: Functions and lambdas capture their environment, ensuring proper variable access in nested scopes.</li> <li>Data Structures: Arrays and dictionaries support dynamic creation and access, with multi-dimensional array operations for nested structures.</li> <li>Error Handling: The VM provides detailed error messages for common issues, such as undefined variables or invalid operations.</li> <li>Extensibility: New opcodes or built-in functions can be added by extending the <code>opcodes</code> module and <code>BytecodeVM</code>\u2019s <code>_add_builtins</code> method.</li> </ul> <p>This bytecode design balances simplicity and functionality, supporting a wide range of programming constructs while maintaining efficient execution.</p>"},{"location":"fluxscript/","title":"FluxScript","text":""},{"location":"fluxscript/#introduction","title":"Introduction","text":"<p>FluxScript (.fs) is a high-level, dynamically typed, functional programming language designed for competitive programming and AI scripting. It prioritizes usability, expressive power, and functional programming principles like immutability where practical. With a robust REPL, FluxScript supports interactive development, making it perfect for rapid prototyping and experimentation.</p>"},{"location":"fluxscript/#language-design","title":"Language Design","text":""},{"location":"fluxscript/#design-choices","title":"Design Choices","text":"<ul> <li>High-level (Python-like): Simple, readable syntax to boost productivity.</li> <li>Dynamically typed: No type declarations required, providing flexibility for quick scripting.</li> <li>Functional: Includes first-class functions, proper closures, and tail-call elimination for efficient recursion.</li> </ul>"},{"location":"fluxscript/#motivation","title":"Motivation","text":"<p>FluxScript aims to strike a balance between power and ease of use, catering to competitive programmers and AI developers. Its interactive REPL enhances the coding experience, ensuring a seamless workflow for users.</p>"},{"location":"fluxscript/#implementation","title":"Implementation","text":""},{"location":"fluxscript/#progress-so-far","title":"Progress So Far","text":"<p>FluxScript\u2019s implementation is complete and reliable: - Core Components:   - Lexer, parser, and evaluator fully implemented to process all language constructs.   - Bytecode compilation for efficient execution(pending) - MUST Features:   - Primitive data types: numbers, booleans, strings, arrays   - Control flow: <code>if-else</code>, <code>while</code>, <code>for</code>, and recursion   - Functions: First-class citizens with proper closure support, tail-call optimization(pending) - DESIRABLE Features:   - Lexically-scoped variables for better organization   - Dictionaries for key-value data storage   - Detailed error messages with line numbers - Testing: Aim to achieve 100% automated test coverage for all features.(Current 81%)</p>"},{"location":"fluxscript/#documentation","title":"Documentation","text":""},{"location":"fluxscript/#user-friendly-documentation","title":"User-Friendly Documentation","text":"<p>FluxScript\u2019s documentation is crafted for accessibility: - Language Reference: Detailed syntax rules and examples for all constructs.README.md - Tutorial: Step-by-step guide for new users, covering REPL usage and basic programming task.getting_started.md - Example:   <code>fluxscript   func square(x) {       return x * x   }   let x = 5   print \"Square of \" + x + \" is \" + square(x)</code>   This snippet showcases variable declaration, function definition, and string concatenation.</p>"},{"location":"fluxscript/#test-coverage","title":"Test Coverage","text":""},{"location":"fluxscript/#ease-of-running-tests","title":"Ease of Running Tests","text":"<ul> <li>Single Command: Run <code>python run_coverage.py</code> to execute the full test suite.</li> <li>Test Suite Breakdown:</li> <li>Unit tests for lexer, parser, evaluator, and AST.</li> <li>Feature tests covering all language constructs.</li> <li>Real-world tests using Euler problems to validate usability.</li> </ul>"},{"location":"fluxscript/#codebase-coverage","title":"Codebase Coverage","text":"<ul> <li>Aim 100% Coverage: Every line of code is tested, ensuring robustness and correctness.</li> </ul>"},{"location":"getting_started/","title":"FluxScript Getting Started","text":"<p>Welcome to FluxScript, a high-level, dynamically typed, functional programming language designed for competitive programming and rapid prototyping. This guide will help you install and run FluxScript, and it includes some tutorial examples to get you started.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Clone the Repository    Clone the project to your local machine:    <code>bash    git clone https://github.com/AtalGupta/Compilers.git    cd Compilers</code></p>"},{"location":"getting_started/#running-fluxscript","title":"Running FluxScript","text":"<p>FluxScript comes with an entry point script named <code>flux.py</code>. You can run FluxScript programs by specifying the source file (with a <code>.fs</code> extension).</p> <p>For example, to run a FluxScript program stored in <code>example.fs</code>, use:</p> <pre><code>python flux.py example.fs\n</code></pre> <p>Alternatively, the provided Bash script <code>test.sh</code> can be used to run your programs. Make sure it has execute permissions:</p> <pre><code>chmod +x test.sh\n./test.sh example.fs\n</code></pre>"},{"location":"getting_started/#tutorial-examples","title":"Tutorial Examples","text":""},{"location":"getting_started/#example-1-hello-world","title":"Example 1: Hello World","text":"<p>Create a file named <code>hello.fs</code> with the following content:</p> <pre><code>print \"Hello, FluxScript!\"\n</code></pre> <p>Run it using:</p> <pre><code>python flux.py hello.fs\n</code></pre>"},{"location":"getting_started/#example-2-variables-and-expressions","title":"Example 2: Variables and Expressions","text":"<p>Create a file named <code>variables.fs</code>:</p> <pre><code>let x = 10\nlet y = 20\nprint \"Sum: \" + (x + y)\n</code></pre> <p>Run it using:</p> <pre><code>python flux.py variables.fs\n</code></pre>"},{"location":"getting_started/#example-3-functions-closures","title":"Example 3: Functions &amp; Closures","text":"<p>FluxScript supports first-class functions and closures. Create a file named <code>counter.fs</code>:</p> <pre><code>func counter() {\n    let count = 0\n    return func() {\n        count assign count + 1\n        return count\n    }\n}\nlet c = counter()\nprint c()  // Outputs: 1\nprint c()  // Outputs: 2\n</code></pre> <p>Run it using:</p> <pre><code>python flux.py counter.fs\n</code></pre>"},{"location":"getting_started/#example-4-conditional-statements-with-elif","title":"Example 4: Conditional Statements with Elif","text":"<p>FluxScript supports if/else and extended elif clauses. Create a file named <code>condition.fs</code>:</p> <pre><code>let x = 5\nif (x &gt; 3) {\n    print \"x is greater than 3\"\n} elif (x == 3) {\n    print \"x equals 3\"\n} else {\n    print \"x is less than 3\"\n}\n</code></pre> <p>Run it using:</p> <pre><code>python flux.py condition.fs\n</code></pre>"},{"location":"getting_started/#example-5-loops-with-break-continue","title":"Example 5: Loops with Break &amp; Continue","text":"<p>Loops have their own lexical scope and can use <code>break</code> and <code>continue</code>. Create a file named <code>loop.fs</code>:</p> <pre><code>for (let i = 1 to 5) {\n    if (i == 3) {\n        continue\n    }\n    print i\n    if (i == 4) {\n        break\n    }\n}\n</code></pre> <p>Run it using:</p> <pre><code>python flux.py loop.fs\n</code></pre>"},{"location":"getting_started/#conclusion","title":"Conclusion","text":"<p>You have now installed FluxScript and seen several examples covering the basics such as printing, variables, functions, control flow with conditionals, and loops. As you explore the language further, consider experimenting with additional features like dictionaries and more advanced functional concepts.</p> <p>Happy coding in FluxScript!</p>"}]}